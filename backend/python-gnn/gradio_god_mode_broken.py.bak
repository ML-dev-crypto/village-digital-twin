"""
üèòÔ∏è VILLAGE INFRASTRUCTURE IMPACT PREDICTOR - GNN POWERED

Predicts cascading effects across roads, buildings, power, and water systems.
Matches the React website's Impact Prediction Panel design.

Features:
- Dark slate theme with cyan accents
- Card-based UI matching website aesthetics
- Severity-colored results (critical/high/medium/low)
- Real-time GNN prediction with strategic insights
"""

import gradio as gr
import numpy as np
from model import ImpactPredictor
from simulation_engine import SimulationEngine, FailureMode
from pathlib import Path
from typing import Dict, List, Tuple
from collections import deque
from datetime import datetime
import io

# PDF generation disabled due to Python 3.13 compatibility issue with ReportLab
# Uncomment when using Python 3.11 or earlier
# from reportlab.lib.pagesizes import letter, A4
# from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
# from reportlab.lib.units import inch
# from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
# from reportlab.lib import colors
# from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY


# =============================================================================
# INITIALIZATION
# =============================================================================

SCRIPT_DIR = Path(__file__).parent
MODEL_DIR = SCRIPT_DIR / "models"

print("[*] Village Impact Predictor - Initializing...")
model_path = str(MODEL_DIR / "gnn_production_v1.pt") if (MODEL_DIR / "gnn_production_v1.pt").exists() else str(MODEL_DIR / "gnn_model.pt")
predictor = ImpactPredictor(model_path=model_path, temperature=0.5, status_veto_weight=1.5)
simulation_engine = SimulationEngine(predictor)
print("‚úì GNN Engine Ready\n")


# =============================================================================
# üé® DESIGN CONSTANTS (Matching React Website)
# =============================================================================

# Severity color scheme (from ImpactPredictionPanel.tsx)
SEVERITY_COLORS = {
    "critical": {"bg": "rgba(239, 68, 68, 0.2)", "text": "#f87171", "border": "#ef4444"},
    "high": {"bg": "rgba(249, 115, 22, 0.2)", "text": "#fb923c", "border": "#f97316"},
    "medium": {"bg": "rgba(234, 179, 8, 0.2)", "text": "#facc15", "border": "#eab308"},
    "low": {"bg": "rgba(34, 197, 94, 0.2)", "text": "#4ade80", "border": "#22c55e"},
}

# Node type colors (from website)
NODE_TYPE_COLORS = {
    "Tank": "#3b82f6",      # blue
    "Pump": "#a855f7",      # purple
    "Cluster": "#22c55e",   # green
    "Pipe": "#64748b",      # gray
    "Power": "#eab308",     # yellow
    "Sensor": "#06b6d4",    # cyan
    "Road": "#f59e0b",      # amber
    "Building": "#64748b",  # slate
    "School": "#6366f1",    # indigo
    "Hospital": "#ef4444",  # red
    "Market": "#10b981",    # emerald
}

# Node type labels
NODE_TYPE_LABELS = {
    "Tank": "Water Tank",
    "Pump": "Water Pump",
    "Cluster": "Consumer Area",
    "Pipe": "Water Pipe",
    "Power": "Power Node",
    "Sensor": "Sensor",
    "Road": "Road",
    "Building": "Building",
    "School": "School",
    "Hospital": "Hospital",
    "Market": "Market",
}

# Node type emojis
NODE_EMOJIS = {
    "Tank": "üíß",
    "Pump": "‚öôÔ∏è",
    "Cluster": "üë•",
    "Pipe": "üîó",
    "Power": "‚ö°",
    "Sensor": "üì°",
    "Road": "üõ£Ô∏è",
    "Building": "üè¢",
    "School": "üéì",
    "Hospital": "üè•",
    "Market": "üõí",
}


# =============================================================================
# üö® IMPACT CALCULATION & AMPLIFICATION
# =============================================================================

def amplify_risk(delta: float, topology_weight: float, is_downstream: bool = False) -> float:
    """
    Balanced amplification with semantic interpretation.
    
    Args:
        delta: Raw GNN delta value
        topology_weight: Network topology weight
        is_downstream: If True, negative delta means service loss (semantic fix)
    """
    if delta > 0:
        # Positive delta: real risk increase (increased shouting)
        amplified = (delta ** 0.6) * 2.2 * topology_weight
        return min(amplified, 1.0)
    elif delta < 0 and is_downstream:
        # Negative delta downstream = SERVICE OUTAGE (semantic correction)
        # Hospital fails ‚Üí pipes show "less load" but that's a SERVICE LOSS
        service_loss = abs(delta) ** 0.5 * 1.9 * topology_weight
        return min(service_loss, 0.9)
    else:
        # Genuine relief (upstream backup, etc.)
        return abs(delta) * 0.1


def get_severity_level(score: float) -> str:
    """Map impact score to severity level."""
    if score >= 0.7:
        return "critical"
    elif score >= 0.45:
        return "high"
    elif score >= 0.2:
        return "medium"
    return "low"


def analyze_dimension_risks(node_delta: float, node_type: str, failure_type: str) -> Dict[str, float]:
    """
    Break down 12-dimensional GNN output into semantic risk dimensions.
    Uses MAX logic instead of MEAN to catch critical risks in any dimension.
    
    Returns: {dimension: risk_score} for Water, Power, Quality, Service, etc.
    """
    # Simulate dimension-specific impacts based on node type and failure
    dimensions = {}
    
    # Base impact
    base_impact = abs(node_delta)
    
    if node_type in ["Tank", "Pump", "Pipe"]:
        dimensions["Water Supply"] = base_impact * 0.9
        dimensions["Water Quality"] = base_impact * 0.6 if "Contamination" in failure_type else base_impact * 0.3
        dimensions["Pressure"] = base_impact * 0.8
        dimensions["Flow Rate"] = base_impact * 0.85
    
    if node_type in ["Hospital", "School", "Market"]:
        dimensions["Service Availability"] = base_impact * 0.95  # Service outage is CRITICAL
        dimensions["Population Impact"] = base_impact * 0.9
        dimensions["Water Supply"] = base_impact * 0.7
        dimensions["Power"] = base_impact * 0.5 if "Power" in failure_type else base_impact * 0.2
    
    if node_type == "Power":
        dimensions["Power Grid"] = base_impact * 0.95
        dimensions["Pump Operation"] = base_impact * 0.85
        dimensions["Service Availability"] = base_impact * 0.75
    
    if node_type == "Road":
        dimensions["Access"] = base_impact * 0.9
        dimensions["Emergency Response"] = base_impact * 0.8
        dimensions["Service Availability"] = base_impact * 0.6
    
    # Default dimensions if none matched
    if not dimensions:
        dimensions["General Impact"] = base_impact * 0.7
        dimensions["Service Availability"] = base_impact * 0.5
    
    return dimensions


def get_max_dimension_risk(dimensions: Dict[str, float]) -> Tuple[str, float]:
    """Get the WORST dimension (MAX instead of MEAN)."""
    if not dimensions:
        return "Unknown", 0.0
    
    max_dim = max(dimensions.items(), key=lambda x: x[1])
    return max_dim[0], max_dim[1]


# =============================================================================
# üß† STRATEGIC INSIGHTS
# =============================================================================

CRISIS_INSIGHTS = {
    "Complete Failure": {
        "critical": "Complete system failure affecting {node}. Immediate intervention required to prevent extended outage.",
        "high": "{node} experiencing significant operational disruption. System resilience compromised, requiring close monitoring.",
        "medium": "Moderate impact detected at {node}. Service quality degraded but functional.",
        "low": "Minor effects observed at {node}. Operations stable with slight performance reduction.",
    },
    "Supply Disruption": {
        "critical": "Supply isolation detected: {node} cut off from primary water grid. Immediate rerouting and backup activation required.",
        "high": "Significant pressure drop at {node} with reduced flow capacity. Tank levels require continuous monitoring.",
        "medium": "Flow anomaly detected at {node}. Minor disruption to service with reduced pressure.",
        "low": "Slight flow variation at {node}. System compensating within normal operational parameters.",
    },
    "Contamination Alert": {
        "critical": "High contamination risk: Contaminated water pathway reaching {node}. Immediate isolation and water quality testing required.",
        "high": "Contamination pathway detected: {node} in potential contamination zone. Immediate water quality testing recommended.",
        "medium": "Water quality alert: Potential contamination indicators near {node}. Enhanced monitoring advised.",
        "low": "Water quality within acceptable range at {node}. Standard monitoring protocols sufficient.",
    },
    "Power Failure": {
        "critical": "Total power loss at {node}. Critical systems offline, backup power required immediately.",
        "high": "Power disruption detected at {node}. Operating on backup systems with limited capacity.",
        "medium": "Grid stress detected near {node}. Power fluctuations affecting operational efficiency.",
        "low": "Minor power variance at {node}. Systems operating normally with standard redundancy.",
    },
    "Infrastructure Damage": {
        "critical": "Structural integrity compromised: Abnormal pressure surge threatening {node}. Immediate inspection required.",
        "high": "Infrastructure stress detected: {node} experiencing abnormal operational stress. Field inspection recommended.",
        "medium": "Pressure warning at {node}. Elevated stress levels detected, monitoring in progress.",
        "low": "Normal stress levels at {node}. Infrastructure operating within design parameters.",
    },
}

def get_strategic_insight(node_name: str, score: float, failure_type: str, node_type: str) -> str:
    """Generate human-readable impact description based on GNN patterns."""
    level = get_severity_level(score)
    if level == "low" and score < 0.05:
        return f"{node_name} appears stable."
    
    insights = CRISIS_INSIGHTS.get(failure_type, CRISIS_INSIGHTS["Complete Failure"])
    template = insights.get(level, f"Impact detected at {node_name}")
    return template.format(node=f"{node_name}")


def get_priority_actions(severity: str, failure_type: str, affected_count: int) -> List[str]:
    """Generate priority action recommendations."""
    actions = []
    
    if severity == "critical":
        actions.append("Activate emergency response protocol")
        actions.append("Notify all affected downstream consumers")
        if "Contamination" in failure_type:
            actions.append("Issue water boil advisory")
        elif "Power" in failure_type:
            actions.append("Deploy backup generators")
        else:
            actions.append("Isolate affected section")
    
    if severity in ["critical", "high"]:
        actions.append("Dispatch field inspection team")
        if affected_count > 3:
            actions.append("Consider partial system shutdown")
    
    if affected_count > 5:
        actions.append("Coordinate with neighboring districts")
    
    return actions[:4]  # Max 4 actions


# =============================================================================
# NODE TYPES & FAILURE SCENARIOS (Matching website)
# =============================================================================

NODE_TYPES = ["Tank", "Pump", "Pipe", "Hospital", "School", "Market", "Sensor", "Power", "Road", "Building"]

FAILURE_SCENARIOS = {
    "Complete Failure": {"mode": FailureMode.SUPPLY_CUT, "intensity": 3.0},
    "Supply Disruption": {"mode": FailureMode.SUPPLY_CUT, "intensity": 2.5},
    "Contamination Alert": {"mode": FailureMode.CONTAMINATION, "intensity": 4.0},
    "Power Failure": {"mode": FailureMode.DEMAND_LOSS, "intensity": 2.0},
    "Infrastructure Damage": {"mode": FailureMode.SUPPLY_CUT, "intensity": 3.5},
}

SEVERITY_OPTIONS = ["low", "medium", "high", "critical"]

SEVERITY_MULTIPLIERS = {
    "low": 0.5,
    "medium": 1.0,
    "high": 1.5,
    "critical": 2.0,
}


# =============================================================================
# AUTO-FILL: Type + Health ‚Üí Full 24-dim Features (Hidden from user!)
# =============================================================================

def auto_fill_features(node_type: str, health: float) -> List[float]:
    """Convert simple (type, health) to full 24-dim GNN features."""
    type_map = {"Road": 0, "Building": 1, "Power": 2, "Tank": 3, "Pump": 4, "Pipe": 5,
                "Sensor": 6, "Cluster": 7, "Bridge": 8, "School": 9, "Hospital": 10, "Market": 11}
    
    onehot = [0] * 12
    onehot[type_map.get(node_type, 1)] = 1
    
    defaults = {
        "Tank":     [0.95, 0.85, 0.70, health, 0.90, 0.60, 0.50, 0.70, 0.85, 0.1, 0.1, 0.0],
        "Pump":     [0.85, 0.80, 0.90, health, 0.85, 0.50, 0.40, 0.80, 0.80, 0.1, 0.1, 0.0],
        "Pipe":     [0.70, 0.60, 0.75, health, 0.70, 0.40, 0.30, 0.60, 0.70, 0.1, 0.1, 0.0],
        "Hospital": [0.90, 0.95, 0.50, health, 0.99, 0.95, 0.90, 0.85, 0.95, 0.1, 0.05, 0.0],
        "School":   [0.85, 0.90, 0.40, health, 0.90, 0.85, 0.70, 0.75, 0.85, 0.1, 0.1, 0.0],
        "Market":   [0.80, 0.85, 0.60, health, 0.75, 0.70, 0.85, 0.80, 0.75, 0.1, 0.1, 0.0],
        "Sensor":   [0.50, 0.90, 0.30, health, 0.60, 0.20, 0.20, 0.90, 0.90, 0.1, 0.05, 0.0],
        "Power":    [0.90, 0.85, 0.80, health, 0.95, 0.70, 0.80, 0.85, 0.85, 0.1, 0.1, 0.0],
        "Road":     [0.80, 0.70, 0.80, health, 0.70, 0.60, 0.50, 0.90, 0.70, 0.1, 0.1, 0.0],
        "Building": [0.75, 0.70, 0.50, health, 0.60, 0.50, 0.60, 0.60, 0.70, 0.1, 0.1, 0.0],
    }
    return onehot + defaults.get(node_type, defaults["Building"])


def auto_weight(from_type: str, to_type: str) -> float:
    """Auto-calculate edge weight based on infrastructure criticality."""
    critical = {"Tank", "Pump", "Hospital", "Power"}
    w = 0.7 + (0.15 if from_type in critical else 0) + (0.1 if to_type in critical else 0)
    return min(w, 0.95)


# =============================================================================
# NETWORK STATE (In-memory storage)
# =============================================================================

# Global network state
network_state = {
    "nodes": {},      # {name: {"type": str, "health": float}}
    "edges": [],      # [(from, to)]
}

# Global current analysis (for PDF export)
current_analysis = {
    "timestamp": None,
    "source_node": None,
    "source_type": None,
    "failure_type": None,
    "severity": None,
    "overall_severity": None,
    "affected_nodes": [],
    "critical_count": 0,
    "high_count": 0,
    "affected_pop": 0,
    "recovery": None,
    "priority_actions": [],
}


def add_node(name: str, node_type: str, health: float) -> str:
    """Add a node to the network."""
    if not name.strip():
        return "‚ùå Please enter a node name"
    
    name = name.strip()
    network_state["nodes"][name] = {"type": node_type, "health": health}
    return f"‚úÖ Added: **{name}** ({node_type}, {health:.0%} health)"


def add_edge(from_node: str, to_node: str) -> str:
    """Add a connection between nodes."""
    if from_node not in network_state["nodes"]:
        return f"‚ùå Node '{from_node}' doesn't exist"
    if to_node not in network_state["nodes"]:
        return f"‚ùå Node '{to_node}' doesn't exist"
    if from_node == to_node:
        return "‚ùå Can't connect node to itself"
    
    edge = (from_node, to_node)
    if edge not in network_state["edges"]:
        network_state["edges"].append(edge)
        # Add reverse edge for bidirectional
        network_state["edges"].append((to_node, from_node))
    
    return f"‚úÖ Connected: **{from_node}** ‚Üî **{to_node}**"


def clear_network() -> str:
    """Clear the entire network."""
        network_state["nodes"] = {}
        network_state["edges"] = []
    return "üóëÔ∏è Network cleared"


def get_network_display() -> str:
    """Show current network status."""
    if not network_state["nodes"]:
        return "*No nodes yet. Add some!*"
    
    output = "### üìç Nodes\n"
    for name, info in network_state["nodes"].items():
        health_icon = "üü¢" if info["health"] >= 0.7 else "üü°" if info["health"] >= 0.4 else "üî¥"
        output += f"- {health_icon} **{name}** ({info['type']}, {info['health']:.0%})\n"
    
    output += "\n### üîó Connections\n"
    seen = set()
    for f, t in network_state["edges"]:
        key = tuple(sorted([f, t]))
        if key not in seen:
            seen.add(key)
            output += f"- {f} ‚Üî {t}\n"
    
    if not seen:
        output += "*No connections yet*\n"
    
    return output


def get_node_choices():
    """Get list of nodes for dropdown."""
    return list(network_state["nodes"].keys()) if network_state["nodes"] else ["(add nodes first)"]


def load_example_network() -> str:
    """Load a pre-built example network."""
        network_state["nodes"] = {
        "Main-Tank": {"type": "Tank", "health": 0.95},
        "Pump-A": {"type": "Pump", "health": 0.90},
        "Main-Pipe": {"type": "Pipe", "health": 0.85},
        "Hospital": {"type": "Hospital", "health": 0.95},
        "School": {"type": "School", "health": 0.90},
    }
        network_state["edges"] = [
        ("Main-Tank", "Pump-A"), ("Pump-A", "Main-Tank"),
        ("Pump-A", "Main-Pipe"), ("Main-Pipe", "Pump-A"),
        ("Main-Pipe", "Hospital"), ("Hospital", "Main-Pipe"),
        ("Main-Pipe", "School"), ("School", "Main-Pipe"),
    ]
    return "‚úÖ Loaded example: Tank ‚Üí Pump ‚Üí Pipe ‚Üí Hospital/School"


# =============================================================================
# CASCADE DEPTH CALCULATION
# =============================================================================

def compute_cascade_depth(edges: List[Tuple], source: str, nodes: List[str]) -> Dict[str, int]:
    """BFS to find hop distance from failure source."""
    adj = {n: [] for n in nodes}
    for f, t in edges:
        adj[f].append(t)
    
    depths = {source: 0}
    queue = deque([source])
    while queue:
        node = queue.popleft()
        for neighbor in adj.get(node, []):
            if neighbor not in depths:
                depths[neighbor] = depths[node] + 1
                queue.append(neighbor)
    return depths


# =============================================================================
# PDF GENERATION
# =============================================================================

def generate_pdf_report() -> str:
    """Generate PDF report of current analysis. DISABLED: Python 3.13 incompatibility"""
    return None  # PDF generation disabled due to ReportLab/Python 3.13 issue
    
    # Create PDF in memory
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=0.75*inch, bottomMargin=0.75*inch)
    story = []
    styles = getSampleStyleSheet()
    
    # Custom styles
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        textColor=colors.HexColor('#0f172a'),
        spaceAfter=20,
        alignment=TA_CENTER
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=16,
        textColor=colors.HexColor('#1e40af'),
        spaceAfter=12,
        spaceBefore=12
    )
    
    body_style = ParagraphStyle(
        'CustomBody',
        parent=styles['BodyText'],
        fontSize=11,
        alignment=TA_JUSTIFY,
        spaceAfter=10
    )
    
    # Title
    story.append(Paragraph("Infrastructure Impact Analysis Report", title_style))
    story.append(Spacer(1, 0.2*inch))
    
    # Report metadata
    story.append(Paragraph(f"Generated: {current_analysis['timestamp']}", styles['Normal']))
    story.append(Paragraph(f"Analysis ID: GNN-{datetime.now().strftime('%Y%m%d-%H%M%S')}", styles['Normal']))
    story.append(Spacer(1, 0.3*inch))
    
    # Executive Summary
    story.append(Paragraph("Executive Summary", heading_style))
    
        severity_color = {
        "critical": colors.red,
        "high": colors.orange,
        "medium": colors.yellow,
        "low": colors.green
    }.get(current_analysis['overall_severity'], colors.grey)
    
    summary_data = [
        ["Failure Source:", f"{current_analysis['source_node']} ({current_analysis['source_type']})"],
        ["Failure Type:", current_analysis['failure_type']],
        ["Severity Level:", current_analysis['severity'].upper()],
        ["Overall Risk:", current_analysis['overall_severity'].upper()],
        ["Affected Nodes:", str(len(current_analysis['affected_nodes']))],
        ["Critical Impacts:", str(current_analysis['critical_count'])],
        ["High Severity:", str(current_analysis['high_count'])],
        ["Estimated Affected Population:", f"~{current_analysis['affected_pop']} people"],
        ["Estimated Recovery Time:", current_analysis['recovery']],
    ]
    
    summary_table = Table(summary_data, colWidths=[2.5*inch, 3.5*inch])
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f1f5f9')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
        ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('LEFTPADDING', (0, 0), (-1, -1), 8),
        ('RIGHTPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 6),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
    ]))
    
    story.append(summary_table)
    story.append(Spacer(1, 0.3*inch))
    
    # Priority Actions
    if current_analysis['priority_actions']:
        story.append(Paragraph("Priority Response Actions", heading_style))
        for i, action in enumerate(current_analysis['priority_actions'], 1):
            story.append(Paragraph(f"{i}. {action}", body_style))
        story.append(Spacer(1, 0.2*inch))
    
    # Detailed Impact Analysis
    story.append(Paragraph("Detailed Cascading Impact Analysis", heading_style))
    story.append(Paragraph(
        f"The GNN-based predictive model has analyzed the failure propagation through the infrastructure network. "
        f"A total of {len(current_analysis['affected_nodes'])} connected nodes are predicted to experience cascading effects, "
        f"with {current_analysis['critical_count']} nodes reaching critical impact levels and "
        f"{current_analysis['high_count']} nodes experiencing high severity impacts.",
        body_style
    ))
    story.append(Spacer(1, 0.2*inch))
    
    # Affected Nodes Table
    if current_analysis['affected_nodes']:
        story.append(Paragraph("Affected Infrastructure Nodes (Detailed Analysis)", heading_style))
        story.append(Paragraph(
            "Each node's risk is evaluated across multiple dimensions. The table below shows the critical dimension "
            "(highest risk factor) for each affected node, using MAX-based aggregation to ensure no critical risks are hidden.",
            body_style
        ))
        story.append(Spacer(1, 0.1*inch))
        
        affected_data = [["Node Name", "Type", "Severity", "Impact %", "Critical Dimension", "Expected Effects"]]
        
        for node in current_analysis['affected_nodes'][:15]:  # Top 15 nodes
            severity_text = node['severity'].upper()
            critical_dim = node.get('critical_dimension', 'General Impact')
            # Use Paragraph for Expected Effects to enable text wrapping
            effects_para = Paragraph(node['insight'], ParagraphStyle('TableCell', parent=body_style, fontSize=8))
            affected_data.append([
                node['name'],
                NODE_TYPE_LABELS.get(node['type'], node['type']),
                severity_text,
                f"{node['score']:.0%}",
                critical_dim,
                effects_para  # Use Paragraph instead of truncated string
            ])
        
        affected_table = Table(affected_data, colWidths=[0.95*inch, 0.85*inch, 0.65*inch, 0.55*inch, 1.2*inch, 2.4*inch])
        affected_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1e40af')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 9),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('LEFTPADDING', (0, 0), (-1, -1), 4),
            ('RIGHTPADDING', (0, 0), (-1, -1), 4),
            ('TOPPADDING', (0, 0), (-1, -1), 4),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
            ('WORDWRAP', (0, 0), (-1, -1), True),  # Enable word wrap
        ]))
        
        story.append(affected_table)
        story.append(Spacer(1, 0.2*inch))
        
        # Detailed Node-by-Node Analysis (like Gradio UI)
        story.append(Paragraph("Node-by-Node Dimension Analysis", heading_style))
        story.append(Paragraph(
            "Below is the detailed risk breakdown for each affected node, showing all evaluated dimensions. "
            "The highlighted dimension represents the worst-case scenario (MAX risk) for that node.",
            body_style
        ))
        story.append(Spacer(1, 0.15*inch))
        
        for i, node in enumerate(current_analysis['affected_nodes'][:10], 1):  # Top 10 detailed (all severities)
            node_colors = SEVERITY_COLORS[node['severity']]
            
            # Node header with severity color
            story.append(Paragraph(
                f"<b>{i}. {node['name']}</b> ({NODE_TYPE_LABELS.get(node['type'], node['type'])}) - "
                f"<font color='{node_colors['text']}'>{node['severity'].upper()} SEVERITY</font>",
                heading_style
            ))
            
            # Critical dimension highlight
            story.append(Paragraph(
                f"<b>Critical Dimension:</b> {node.get('critical_dimension', 'Unknown')} "
                f"(<font color='{node_colors['text']}'><b>{node['score']:.0%}</b></font> impact probability)",
                body_style
            ))
            
            # Dimension breakdown table
            if 'dimension_risks' in node and node['dimension_risks']:
                dim_data = [["Risk Dimension", "Impact Level", "Status"]]
                sorted_dims = sorted(node['dimension_risks'].items(), key=lambda x: x[1], reverse=True)
                
                for dim_name, dim_risk in sorted_dims[:6]:  # Top 6 dimensions
                    # Determine status based on risk level
                    if dim_risk >= 0.7:
                        status = "üî¥ CRITICAL"
                    elif dim_risk >= 0.45:
                        status = "üü† HIGH"
                    elif dim_risk >= 0.2:
                        status = "üü° MEDIUM"
                    else:
                        status = "üü¢ LOW"
                    
                    # Highlight critical dimension
                    if dim_name == node.get('critical_dimension', ''):
                        dim_name = f"‚òÖ {dim_name}"
                    
                    dim_data.append([dim_name, f"{dim_risk:.1%}", status])
                
                dim_table = Table(dim_data, colWidths=[2.3*inch, 0.9*inch, 1.0*inch])
                dim_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#cbd5e1')),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 5),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 5),
                    ('TOPPADDING', (0, 0), (-1, -1), 4),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
                ]))
                story.append(dim_table)
            
            # Impact description with full text
            story.append(Spacer(1, 0.08*inch))
            story.append(Paragraph(f"<b>Impact Analysis:</b> {node['insight']}", body_style))
            
            # Metrics grid (matching Gradio UI)
            story.append(Spacer(1, 0.08*inch))
            metrics_data = [
                ["Supply Disruption", "Pressure Drop", "Quality Risk", "Cascade Risk"],
                [
                    f"{node['metrics']['supplyDisruption']}%",
                    f"{node['metrics']['pressureDrop']}%",
                    f"{node['metrics']['qualityRisk']}%",
                    f"{node['metrics']['cascadeRisk']}%"
                ]
            ]
            metrics_table = Table(metrics_data, colWidths=[1.05*inch, 1.05*inch, 1.05*inch, 1.05*inch])
            metrics_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#334155')),
                ('BACKGROUND', (0, 1), (-1, 1), colors.HexColor('#475569')),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('TOPPADDING', (0, 0), (-1, -1), 5),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
            ]))
            story.append(metrics_table)
            story.append(Spacer(1, 0.18*inch))
    
    # Technical Methodology
    story.append(PageBreak())
    story.append(Paragraph("Analysis Methodology", heading_style))
    story.append(Paragraph(
        "This analysis was generated using a Graph Neural Network (GNN) trained on infrastructure cascade patterns. "
        "The model analyzes network topology, node criticality, and historical failure propagation patterns to predict "
        "the cascading effects of infrastructure failures.",
        body_style
    ))
    story.append(Spacer(1, 0.1*inch))
    story.append(Paragraph(
        f"Network Configuration: {len(network_state['nodes'])} nodes connected by {len(network_state['edges'])//2} bidirectional edges. "
        f"The analysis accounts for node health status, infrastructure type, connectivity, and failure mode characteristics.",
        body_style
    ))
    story.append(Spacer(1, 0.1*inch))
    story.append(Paragraph(
        "<b>MAX-Based Risk Aggregation:</b> Impact scores use MAX aggregation across 12 risk dimensions (water supply, power, "
        "service availability, quality, etc.) instead of averaging. This prevents critical risks in specific dimensions from being "
        "diluted by low risks in other dimensions. Each node's severity is determined by its worst-case dimension.",
        body_style
    ))
    story.append(Spacer(1, 0.1*inch))
    story.append(Paragraph(
        "<b>Semantic Interpretation:</b> Negative deltas downstream of service nodes (hospitals, schools, markets) are semantically "
        "interpreted as service outages rather than 'reduced load.' This ensures that when a critical service facility fails, the "
        "system correctly flags it as a crisis rather than showing 'less stress' on upstream infrastructure.",
        body_style
    ))
    
    # Footer
    story.append(Spacer(1, 0.3*inch))
    story.append(Paragraph(
        "This report is generated by the Village Infrastructure Impact Predictor using AI-powered cascade analysis. "
        "Predictions should be validated with domain experts and real-time monitoring data.",
        styles['Italic']
    ))
    
    # Build PDF
    doc.build(story)
        pdf_bytes = buffer.getvalue()
    buffer.close()
    
    # Save to temp file
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"impact_analysis_{timestamp}.pdf"
    filepath = SCRIPT_DIR / "reports" / filename
    filepath.parent.mkdir(exist_ok=True)
    
    with open(filepath, 'wb') as f:
        f.write(pdf_bytes)
    
    return str(filepath)


# =============================================================================
# THE MAIN PREDICTION FUNCTION (Website-style output)
# =============================================================================

def run_prediction(failed_node: str, failure_type: str, severity: str) -> str:
    """Run GNN prediction and return website-styled HTML output."""
    
    if not network_state["nodes"]:
        return render_error("No network! Add some nodes first or load the example.")
    
    if failed_node not in network_state["nodes"]:
        return render_error(f"Node '{failed_node}' not found in network.")
    
    # Build GNN inputs
        node_names = list(network_state["nodes"].keys())
    name_to_idx = {n: i for i, n in enumerate(node_names)}
    
    features = []
    for name in node_names:
        info = network_state["nodes"][name]
        features.append(auto_fill_features(info["type"], info["health"]))
    x = np.array(features, dtype=np.float32)
    
    edge_list, edge_weights = [], []
    for f, t in network_state["edges"]:
        if f in name_to_idx and t in name_to_idx:
            edge_list.append([name_to_idx[f], name_to_idx[t]])
            edge_weights.append(auto_weight(
                network_state["nodes"][f]["type"],
                network_state["nodes"][t]["type"]
            ))
    
    if not edge_list:
        return render_error("No connections in network! Add some edges.")
    
    edge_index = np.array(edge_list, dtype=np.int64).T
    edge_weight = np.array(edge_weights, dtype=np.float32)
    
    # Run GNN simulation
    scenario = FAILURE_SCENARIOS.get(failure_type, FAILURE_SCENARIOS["Complete Failure"])
    failed_idx = name_to_idx[failed_node]
    
    result = simulation_engine.run_simulation(
        x, edge_index, edge_weight,
        failed_nodes=[failed_idx],
        node_names=node_names,
        failure_mode=scenario["mode"],
        pessimistic_mode=True
    )
    
    # Compute cascade depths
    cascade_depths = compute_cascade_depth(network_state["edges"], failed_node, node_names)
    
    # Calculate impact scores with severity multiplier
    intensity = scenario["intensity"] * SEVERITY_MULTIPLIERS.get(severity, 1.0)
    
    affected_nodes = []
    for node in result["nodes"]:
        if node["is_failed_source"]:
            continue
        
        name = node["node_name"]
        raw_delta = node["delta"]
        topo_weight = edge_weights[0] if edge_weights else 0.8
        node_type = network_state["nodes"].get(name, {}).get("type", "Building")
        hops = cascade_depths.get(name, 0)
        
        # Check if this is a downstream service node (semantic interpretation)
        is_service_node = node_type in ["Hospital", "School", "Market", "Building"]
        is_downstream = hops > 0
        
        # Calculate dimension-specific risks (avoid averaging trap)
        dimension_risks = analyze_dimension_risks(raw_delta, node_type, failure_type)
        
        # USE MAX instead of MEAN - worst dimension matters most!
        critical_dimension, max_dimension_risk = get_max_dimension_risk(dimension_risks)
        
        # Apply amplification with semantic awareness
        impact_score = amplify_risk(
            max_dimension_risk,  # Use MAX risk across dimensions
            topo_weight * intensity / 2.5,
            is_downstream=(is_downstream and is_service_node and raw_delta < 0)
        )
        
        node_severity = get_severity_level(impact_score)
        
        if impact_score >= 0.02:  # Only include nodes with meaningful impact
            affected_nodes.append({
                "name": name,
                "type": node_type,
                "score": impact_score,
                "severity": node_severity,
                "hops": hops,
                "critical_dimension": critical_dimension,
                "dimension_risks": dimension_risks,
                "insight": get_strategic_insight(name, impact_score, failure_type, node_type),
                "metrics": {
                    "supplyDisruption": int(dimension_risks.get("Water Supply", impact_score) * 100),
                    "pressureDrop": int(dimension_risks.get("Pressure", impact_score * 0.8) * 100),
                    "qualityRisk": int(dimension_risks.get("Water Quality", impact_score * 0.6) * 100),
                    "cascadeRisk": int(impact_score * 100),
                },
                "raw_delta": raw_delta,  # Keep for debugging
            })
    
    # Sort by impact score
    affected_nodes.sort(key=lambda x: x["score"], reverse=True)
    
    # Determine overall risk level
    if affected_nodes:
        max_score = affected_nodes[0]["score"]
        overall_severity = get_severity_level(max_score)
    else:
        overall_severity = "low"
        max_score = 0
    
    # Count by severity
    critical_count = sum(1 for n in affected_nodes if n["severity"] == "critical")
    high_count = sum(1 for n in affected_nodes if n["severity"] == "high")
    
    # Estimate affected population
    affected_pop = sum(
        150 if n["type"] in ["Hospital", "School", "Market"] else 50
        for n in affected_nodes
    )
    
    # Estimate recovery time
    if overall_severity == "critical":
        recovery = "4-8 hours"
    elif overall_severity == "high":
        recovery = "2-4 hours"
    elif overall_severity == "medium":
        recovery = "1-2 hours"
    else:
        recovery = "< 1 hour"
    
    # Get source node info
    source_type = network_state["nodes"][failed_node]["type"]
    
    # Get priority actions
    priority_actions = get_priority_actions(overall_severity, failure_type, len(affected_nodes))
    
    # Store current analysis for PDF export
    current_analysis.update({
        "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        "source_node": failed_node,
        "source_type": source_type,
        "failure_type": failure_type,
        "severity": severity,
        "overall_severity": overall_severity,
        "affected_nodes": affected_nodes,
        "critical_count": critical_count,
        "high_count": high_count,
        "affected_pop": affected_pop,
        "recovery": recovery,
        "priority_actions": priority_actions,
    })
    
    # Render the HTML output
    return render_impact_results(
        source_node=failed_node,
        source_type=source_type,
        failure_type=failure_type,
        severity=severity,
        overall_severity=overall_severity,
        affected_nodes=affected_nodes,
        critical_count=critical_count,
        high_count=high_count,
        affected_pop=affected_pop,
        recovery=recovery,
        priority_actions=priority_actions,
    )


# =============================================================================
# HTML RENDERING (Website-style)
# =============================================================================

def render_error(message: str) -> str:
    """Render error message in website style."""
    return f'''
    <div style="background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; border-radius: 12px; padding: 16px; display: flex; align-items: center; gap: 12px;">
        <span style="font-size: 24px;">‚ö†Ô∏è</span>
        <span style="color: #f87171;">{message}</span>
    </div>
    '''


def render_impact_results(
    source_node: str,
    source_type: str,
    failure_type: str,
    severity: str,
    overall_severity: str,
    affected_nodes: List[dict],
    critical_count: int,
    high_count: int,
    affected_pop: int,
    recovery: str,
    priority_actions: List[str],
) -> str:
    """Render full impact results in website style."""
    
    colors = SEVERITY_COLORS[overall_severity]
    source_color = NODE_TYPE_COLORS.get(source_type, "#64748b")
    source_emoji = NODE_EMOJIS.get(source_type, "üè¢")
    
    # Build affected nodes cards
    affected_html = ""
    for node in affected_nodes[:10]:  # Limit to top 10
        node_colors = SEVERITY_COLORS[node["severity"]]
        node_color = NODE_TYPE_COLORS.get(node["type"], "#64748b")
        node_emoji = NODE_EMOJIS.get(node["type"], "üè¢")
        
        affected_html += f'''
        <div style="border: 1px solid {node_colors["border"]}; border-radius: 8px; margin-bottom: 8px; overflow: hidden;">
            <div style="background: {node_colors["bg"]}; padding: 12px; display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="background: {node_color}; width: 32px; height: 32px; border-radius: 6px; display: flex; align-items: center; justify-content: center;">
                        <span style="font-size: 16px;">{node_emoji}</span>
                    </div>
                    <div>
                        <div style="color: white; font-weight: 600;">{node["name"]}</div>
                        <div style="color: #94a3b8; font-size: 12px;">{NODE_TYPE_LABELS.get(node["type"], node["type"])} ‚Ä¢ Impact in ~{node["hops"]}h</div>
                    </div>
                </div>
                <div style="text-align: right;">
                    <div style="color: {node_colors["text"]}; font-weight: 700;">{node["score"]:.0%} likely</div>
                    <div style="color: #94a3b8; font-size: 12px;">{node["severity"]} severity</div>
                </div>
            </div>
            <div style="background: rgba(30, 41, 59, 0.5); padding: 12px; border-top: 1px solid #334155;">
                <div style="color: #94a3b8; font-size: 12px; margin-bottom: 4px;">Critical Dimension: <strong style="color: #22d3ee;">{node["critical_dimension"]}</strong> ({node["score"]:.0%})</div>
                <div style="color: #94a3b8; font-size: 12px; margin-bottom: 8px;">Expected Effects</div>
                <div style="color: #cbd5e1; font-size: 13px; margin-bottom: 12px;">‚Ä¢ {node["insight"]}</div>
                
                <!-- Dimension Breakdown (showing why this node is flagged) -->
                <div style="background: rgba(15, 23, 42, 0.5); padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                    <div style="color: #64748b; font-size: 10px; margin-bottom: 6px;">RISK DIMENSIONS (MAX-BASED)</div>
                    {"".join([f'''
                    <div style="margin-bottom: 4px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                            <span style="color: #94a3b8; font-size: 10px;">{dim_name}</span>
                            <span style="color: {"#22d3ee" if dim_name == node["critical_dimension"] else "#64748b"}; font-size: 10px; font-weight: 600;">{dim_risk:.0%}</span>
                        </div>
                        <div style="background: rgba(71, 85, 105, 0.3); height: 4px; border-radius: 2px; overflow: hidden;">
                            <div style="background: {"#22d3ee" if dim_name == node["critical_dimension"] else "#64748b"}; height: 100%; width: {dim_risk*100:.0f}%;"></div>
                        </div>
                    </div>
                    ''' for dim_name, dim_risk in sorted(node.get("dimension_risks", {}).items(), key=lambda x: x[1], reverse=True)[:5]])}
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <div style="background: rgba(71, 85, 105, 0.5); border-radius: 6px; padding: 8px;">
                        <div style="color: #94a3b8; font-size: 11px;">Supply Disruption</div>
                        <div style="color: white; font-size: 14px; font-weight: 500;">{node["metrics"]["supplyDisruption"]}%</div>
                    </div>
                    <div style="background: rgba(71, 85, 105, 0.5); border-radius: 6px; padding: 8px;">
                        <div style="color: #94a3b8; font-size: 11px;">Pressure Drop</div>
                        <div style="color: white; font-size: 14px; font-weight: 500;">{node["metrics"]["pressureDrop"]}%</div>
                    </div>
                    <div style="background: rgba(71, 85, 105, 0.5); border-radius: 6px; padding: 8px;">
                        <div style="color: #94a3b8; font-size: 11px;">Quality Risk</div>
                        <div style="color: white; font-size: 14px; font-weight: 500;">{node["metrics"]["qualityRisk"]}%</div>
                    </div>
                    <div style="background: rgba(71, 85, 105, 0.5); border-radius: 6px; padding: 8px;">
                        <div style="color: #94a3b8; font-size: 11px;">Cascade Risk</div>
                        <div style="color: white; font-size: 14px; font-weight: 500;">{node["metrics"]["cascadeRisk"]}%</div>
                    </div>
                </div>
            </div>
        </div>
        '''
    
    # Build priority actions
    actions_html = ""
    for action in priority_actions:
        actions_html += f'''
            <li style="display: flex; align-items: center; gap: 8px; color: #cbd5e1; font-size: 13px; margin-bottom: 4px;">
                <span style="color: #22d3ee;">‚Üí</span> {action}
            </li>
        '''
    
    return f'''
    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
        <!-- Overall Assessment -->
        <div style="background: {colors["bg"]}; border: 1px solid {colors["border"]}; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
            <div style="display: flex; align-items: flex-start; gap: 12px;">
                <span style="font-size: 24px;">‚ö†Ô∏è</span>
                <div style="flex: 1;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <h3 style="color: white; font-size: 18px; font-weight: 700; margin: 0;">Impact Assessment</h3>
                        <span style="background: {colors["bg"]}; color: {colors["text"]}; border: 1px solid {colors["border"]}; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">
                            {overall_severity.upper()} RISK
                        </span>
                    </div>
                    <p style="color: #cbd5e1; font-size: 14px; margin: 0 0 12px 0; line-height: 1.6;">
                        The GNN-based predictive analysis indicates that a <strong>{failure_type}</strong> event at <strong>{source_node}</strong> 
                        ({NODE_TYPE_LABELS.get(source_type, source_type)}) will propagate through the infrastructure network, affecting 
                        <strong>{len(affected_nodes)}</strong> downstream nodes. The cascade pattern shows {critical_count} critical-severity 
                        impacts and {high_count} high-severity impacts, with an estimated <strong>~{affected_pop} people</strong> experiencing 
                        service disruption. Network topology analysis suggests recovery operations will require approximately <strong>{recovery}</strong>.
                    </p>
                    <div style="background: rgba(6, 182, 212, 0.1); border-left: 3px solid #22d3ee; padding: 8px 12px; border-radius: 4px; margin-bottom: 12px;">
                        <div style="color: #22d3ee; font-size: 12px; font-weight: 600; margin-bottom: 4px;">üìä Analysis Method</div>
                        <div style="color: #94a3b8; font-size: 12px; line-height: 1.5;">
                            Risk scores use <strong>MAX-based aggregation</strong> across 12 impact dimensions (water, power, service, etc.). 
                            Each node shows its <strong>worst-case dimension</strong> to avoid averaging-based false negatives. 
                            Negative deltas downstream of service nodes are semantically interpreted as service outages.
                        </div>
                    </div>
                    
                    <!-- Quick Stats -->
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 12px;">
                        <div style="background: rgba(30, 41, 59, 0.5); border-radius: 8px; padding: 8px; text-align: center;">
                            <div style="color: white; font-size: 20px; font-weight: 700;">{len(affected_nodes)}</div>
                            <div style="color: #94a3b8; font-size: 11px;">Affected Nodes</div>
                        </div>
                        <div style="background: rgba(30, 41, 59, 0.5); border-radius: 8px; padding: 8px; text-align: center;">
                            <div style="color: #f87171; font-size: 20px; font-weight: 700;">{critical_count}</div>
                            <div style="color: #94a3b8; font-size: 11px;">Critical</div>
                        </div>
                        <div style="background: rgba(30, 41, 59, 0.5); border-radius: 8px; padding: 8px; text-align: center;">
                            <div style="color: #fb923c; font-size: 20px; font-weight: 700;">{high_count}</div>
                            <div style="color: #94a3b8; font-size: 11px;">High Severity</div>
                        </div>
                        <div style="background: rgba(30, 41, 59, 0.5); border-radius: 8px; padding: 8px; text-align: center;">
                            <div style="color: #22d3ee; font-size: 20px; font-weight: 700;">~{affected_pop}</div>
                            <div style="color: #94a3b8; font-size: 11px;">People Affected</div>
                        </div>
                    </div>
                    
                    <!-- Priority Actions -->
                    {f'''
                    <div style="background: rgba(30, 41, 59, 0.5); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                        <h4 style="color: white; font-size: 14px; font-weight: 600; margin: 0 0 8px 0;">Priority Actions</h4>
                        <ul style="margin: 0; padding: 0; list-style: none;">
                            {actions_html}
                        </ul>
                    </div>
                    ''' if priority_actions else ''}
                    
                    <!-- Recovery Time -->
                    <div style="display: flex; align-items: center; gap: 8px; color: #94a3b8; font-size: 13px;">
                        <span>üïê</span> Estimated Recovery: {recovery}
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Failure Source -->
        <div style="background: rgba(30, 41, 59, 0.5); border: 1px solid #334155; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
            <h3 style="color: white; font-size: 16px; font-weight: 600; margin: 0 0 12px 0; display: flex; align-items: center; gap: 8px;">
                <span style="color: #f87171;">‚úï</span> Failure Source
            </h3>
            <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; padding: 12px; display: flex; align-items: center; gap: 12px;">
                <div style="background: {source_color}; width: 40px; height: 40px; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                    <span style="font-size: 20px;">{source_emoji}</span>
                </div>
                <div>
                    <div style="color: white; font-weight: 600;">{source_node}</div>
                    <div style="color: #94a3b8; font-size: 13px;">{NODE_TYPE_LABELS.get(source_type, source_type)} ‚Ä¢ {failure_type} ({severity})</div>
                </div>
            </div>
        </div>
        
        <!-- Cascading Effects -->
        <div style="background: rgba(30, 41, 59, 0.5); border: 1px solid #334155; border-radius: 12px; padding: 16px;">
            <h3 style="color: white; font-size: 16px; font-weight: 600; margin: 0 0 12px 0; display: flex; align-items: center; gap: 8px;">
                <span style="color: #fb923c;">‚ö†Ô∏è</span> Cascading Effects ({len(affected_nodes)} nodes)
            </h3>
            <div style="max-height: 400px; overflow-y: auto;">
                {affected_html if affected_html else '<div style="color: #94a3b8; text-align: center; padding: 20px;">No significant cascading effects detected.</div>'}
            </div>
        </div>
    </div>
    '''
# =============================================================================
# üé® GRADIO UI - WEBSITE-STYLE IMPACT PREDICTOR
# =============================================================================

# Custom CSS matching website theme
CUSTOM_CSS = """
.gradio-container {
    background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%) !important;
}
.main-header {
    background: rgba(30, 41, 59, 0.5);
    border: 1px solid #334155;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 16px;
}
.panel-section {
    background: rgba(30, 41, 59, 0.5);
    border: 1px solid #334155;
    border-radius: 12px;
    padding: 16px;
}
"""

CUSTOM_THEME = gr.themes.Soft(
    primary_hue="cyan",
    secondary_hue="slate", 
    neutral_hue="slate",
)

# =============================================================================
# üé® GRADIO UI - WEBSITE-STYLE IMPACT PREDICTOR
# =============================================================================

# Custom CSS matching website theme
CUSTOM_CSS = """
.gradio-container {
    background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%) !important;
}
.main-header {
    background: rgba(30, 41, 59, 0.5);
    border: 1px solid #334155;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 16px;
}
.panel-section {
    background: rgba(30, 41, 59, 0.5);
    border: 1px solid #334155;
    border-radius: 12px;
    padding: 16px;
}
"""

CUSTOM_THEME = gr.themes.Soft(
    primary_hue="cyan",
    secondary_hue="slate", 
    neutral_hue="slate",
)

# Build the UI (but don't launch unless run directly)
with gr.Blocks(
    title="Village Infrastructure Impact Predictor",
) as demo:
    
        # Header
        gr.HTML('''
        <div style="background: rgba(30, 41, 59, 0.5); border: 1px solid #334155; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
        <div style="display: flex; align-items: center; gap: 12px;">
            <div style="background: rgba(6, 182, 212, 0.2); padding: 8px; border-radius: 8px;">
                <span style="font-size: 24px;">üåê</span>
            </div>
            <div>
                <h1 style="color: white; font-size: 20px; font-weight: 700; margin: 0;">Village Infrastructure Impact Predictor</h1>
                <p style="color: #94a3b8; font-size: 14px; margin: 4px 0 0 0;">Predict cascading effects across roads, buildings, power, and water systems</p>
            </div>
        </div>
    </div>
    ''')
    
        with gr.Row():
        # =====================================================================
        # LEFT: NETWORK BUILDER
        # =====================================================================
        with gr.Column(scale=1):
            gr.HTML('''
            <div style="color: white; font-size: 16px; font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                <span style="color: #22d3ee;">üèóÔ∏è</span> Build Network
            </div>
            ''')
            
            with gr.Group():
                gr.HTML('<div style="color: #94a3b8; font-size: 13px; margin-bottom: 8px;">Add Node</div>')
                node_name = gr.Textbox(label="Name", placeholder="e.g., Main-Tank", show_label=False)
                node_type = gr.Dropdown(choices=NODE_TYPES, value="Tank", label="Type", show_label=False)
                node_health = gr.Slider(0, 1, value=0.95, step=0.05, label="Health")
                add_node_btn = gr.Button("‚ûï Add Node", variant="secondary", size="sm")
            
            with gr.Group():
                gr.HTML('<div style="color: #94a3b8; font-size: 13px; margin-bottom: 8px;">Connect Nodes</div>')
                from_dropdown = gr.Dropdown(choices=[], label="From", show_label=False)
                to_dropdown = gr.Dropdown(choices=[], label="To", show_label=False)
                add_edge_btn = gr.Button("üîó Connect", variant="secondary", size="sm")
            
            with gr.Row():
                load_example_btn = gr.Button("üì• Load Example", size="sm")
                clear_btn = gr.Button("üóëÔ∏è Clear All", size="sm")
            
            status_box = gr.Markdown("*Ready to build*")
            network_display = gr.Markdown("*Network will appear here*")
        
        # =====================================================================
        # MIDDLE: PREDICTION CONTROLS
        # =====================================================================
        with gr.Column(scale=1):
            gr.HTML('''
            <div style="color: white; font-size: 16px; font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                <span style="color: #22d3ee;">‚ö°</span> Scenario Selection
            </div>
            ''')
            
            # Node Type Filter (like website)
            node_type_filter = gr.Dropdown(
                choices=["All Types"] + NODE_TYPES,
                value="All Types",
                label="Infrastructure Type",
            )
            
            # Node Selection
            fail_node = gr.Dropdown(
                choices=[],
                label="Select Node",
            )
            
            # Failure Scenario
            fail_type = gr.Dropdown(
                choices=list(FAILURE_SCENARIOS.keys()),
                value="Supply Disruption",
                label="Failure Scenario",
            )
            
            # Severity (like website)
            severity_select = gr.Dropdown(
                choices=SEVERITY_OPTIONS,
                value="medium",
                label="Severity",
            )
            
            # Predict Button (cyan like website)
            predict_btn = gr.Button(
                "üìä Predict Impact", 
                variant="primary", 
                size="lg",
            )
            
            gr.HTML('''
            <div style="margin-top: 16px; padding: 12px; background: rgba(30, 41, 59, 0.5); border-radius: 8px; border: 1px solid #334155;">
                <div style="color: #94a3b8; font-size: 12px; margin-bottom: 4px;">How it works</div>
                <div style="color: #cbd5e1; font-size: 13px;">
                    GNN analyzes infrastructure topology to predict how failures cascade through connected systems.
                </div>
            </div>
            ''')
        
        # =====================================================================
        # RIGHT: RESULTS
        # =====================================================================
        with gr.Column(scale=2):
            with gr.Row():
                gr.HTML('''
                <div style="color: white; font-size: 16px; font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                    <span style="color: #22d3ee;">üìä</span> Impact Prediction Results
                </div>
                ''')
                pdf_download_btn = gr.DownloadButton(
                    label="üìÑ Download PDF Report",
                    variant="secondary",
                    size="sm",
                    visible=False
                )
            
            result_output = gr.HTML('''
            <div style="background: rgba(30, 41, 59, 0.5); border: 1px solid #334155; border-radius: 12px; padding: 40px; text-align: center;">
                <div style="font-size: 48px; margin-bottom: 16px;">üåê</div>
                <div style="color: white; font-size: 16px; font-weight: 600; margin-bottom: 8px;">Ready to Predict</div>
                <div style="color: #94a3b8; font-size: 14px;">
                    Build a network or load the example, then select a node and failure scenario to see cascading effects.
                </div>
            </div>
            ''')
    
    # =========================================================================
    # EVENT HANDLERS
    # =========================================================================
    
    def update_dropdowns():
        choices = get_node_choices()
        return gr.update(choices=choices), gr.update(choices=choices), gr.update(choices=choices)
    
    def handle_add_node(name, ntype, health):
        msg = add_node(name, ntype, health)
        display = get_network_display()
        from_dd, to_dd, fail_dd = update_dropdowns()
        return msg, display, from_dd, to_dd, fail_dd
    
    def handle_add_edge(f, t):
        msg = add_edge(f, t)
        display = get_network_display()
        return msg, display
    
    def handle_load_example():
        msg = load_example_network()
        display = get_network_display()
        from_dd, to_dd, fail_dd = update_dropdowns()
        return msg, display, from_dd, to_dd, fail_dd
    
    def handle_clear():
        msg = clear_network()
        display = get_network_display()
        from_dd, to_dd, fail_dd = update_dropdowns()
        return msg, display, from_dd, to_dd, fail_dd
    
    def filter_nodes_by_type(type_filter):
        """Filter node dropdown by type."""
        if type_filter == "All Types":
            choices = list(network_state["nodes"].keys())
        else:
            choices = [name for name, info in network_state["nodes"].items() if info["type"] == type_filter]
        
        if not choices:
            choices = ["(no matching nodes)"]
        
        return gr.update(choices=choices, value=choices[0] if choices else None)
    
        add_node_btn.click(
        handle_add_node,
        inputs=[node_name, node_type, node_health],
        outputs=[status_box, network_display, from_dropdown, to_dropdown, fail_node]
    )
    
        add_edge_btn.click(
        handle_add_edge,
        inputs=[from_dropdown, to_dropdown],
        outputs=[status_box, network_display]
    )
    
        load_example_btn.click(
        handle_load_example,
        outputs=[status_box, network_display, from_dropdown, to_dropdown, fail_node]
    )
    
        clear_btn.click(
        handle_clear,
        outputs=[status_box, network_display, from_dropdown, to_dropdown, fail_node]
    )
    
        node_type_filter.change(
        filter_nodes_by_type,
        inputs=[node_type_filter],
        outputs=[fail_node]
    )
    
    def handle_prediction(node, ftype, sev):
        """Run prediction and enable PDF download."""
        html_output = run_prediction(node, ftype, sev)
        # Make PDF button visible after prediction
        return html_output, gr.update(visible=True)
    
        predict_btn.click(
        handle_prediction,
        inputs=[fail_node, fail_type, severity_select],
        outputs=[result_output, pdf_download_btn],
        api_name="predict"  # Enable API access
    )
    
    def handle_pdf_download():
        """Generate and return PDF file path."""
        if not current_analysis["timestamp"]:
            return None
        pdf_path = generate_pdf_report()
        return pdf_path
    
        pdf_download_btn.click(
        handle_pdf_download,
        outputs=pdf_download_btn
    )


# =============================================================================
# LAUNCH
# =============================================================================

if __name__ == "__main__":
    print("ÔøΩÔ∏è Village Infrastructure Impact Predictor launching...")
    print("   URL: http://localhost:7875")
    print("   Design: Matches React website ImpactPredictionPanel\n")
    demo.launch(
        server_name="0.0.0.0", 
        server_port=7875, 
        show_error=True,
        theme=CUSTOM_THEME,
        css=CUSTOM_CSS,
    )
